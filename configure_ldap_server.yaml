# Play 2: Configure the newly created server
- name: Configure New Vultr Ubuntu OpenLDAP Server
  hosts: vultr_servers # Target the dynamic group created above
  become: true         # Most config tasks need sudo/root
  gather_facts: true   # Gather facts from the remote server

  vars_files:
    # Include the vault file if you created open
    - vars/ldap_secrets.yaml

  # Optional: Define variables specific to this play/host group
  vars:
    # --- Basic LDAP Configuration ---
    ldap_domain_components: ['still-learning', 'tech'] # e.g., for still-learning.tech
    ldap_organization: "Still Learning LLC"            # The organization name

    # Derive Base DN and Root DN
    ldap_base_dn: "{{ ldap_domain_components | map('regex_replace', '^(.*)$', 'dc=\\1') | join(',') }}" # dc=still-learning,dc=tech
    ldap_admin_cn: "admin"
    ldap_root_dn: "cn={{ ldap_admin_cn }},{{ ldap_base_dn }}" # cn=admin,dc=still-learning,dc=tech

    # ** SECURITY WARNING **: Use the hashed password from Vault (ldap_root_password_hashed)
    # If *not* using Vault (NOT RECOMMENDED for production), you could use plain text:
    # ldap_root_password_plain: "YourSecretPasswordGoesHere" # Less secure alternative

    # --- TLS Configuration ---
    # Location where the renewal hook will copy LE certs for slapd to use
    ldap_tls_certs_path_final: "/etc/ldap/ssl"
    # These filenames match what the hook script will create
    ldap_tls_key_file_final: "{{ ldap_tls_certs_path_final }}/privkey.pem"
    ldap_tls_cert_file_final: "{{ ldap_tls_certs_path_final }}/fullchain.pem"
    ldap_tls_cacert_file_final: "{{ ldap_tls_certs_path_final }}/chain.pem" # Optional, often fullchain is sufficient

    # Let's Encrypt paths (standard locations)
    letsencrypt_live_path: "/etc/letsencrypt/live/{{ ldap_public_domain }}"
    letsencrypt_cert: "{{ letsencrypt_live_path }}/cert.pem"
    letsencrypt_chain: "{{ letsencrypt_live_path }}/chain.pem"
    letsencrypt_fullchain: "{{ letsencrypt_live_path }}/fullchain.pem"
    letsencrypt_privkey: "{{ letsencrypt_live_path }}/privkey.pem"

    # Debconf selections for slapd package
    slapd_debconf_selections:
      # Basic settings
      - name: slapd/domain
        question: slapd/domain
        type: string
        value: "{{ ldap_domain_components | join('.') }}" # example.com
      - name: slapd/organization
        question: slapd/organization
        type: string
        value: "{{ ldap_organization }}"
      # Admin Password - uses the *hashed* value
      - name: slapd/root_password_hash # Note: Use this for hashed password input
        question: slapd/root_password_hash
        type: password # Type might be interpreted; using password for clarity
        value: "{{ ldap_root_password_hashed }}"
      # Confirmation (Not needed if providing hash directly)
      # - name: slapd/root_password_again
      #   question: slapd/root_password_again
      #   type: password
      #   value: "{{ ldap_root_password_plain | default(omit) }}" # Only if using plain text method

      # Backend choice (default is usually fine)
      - name: slapd/backend
        question: slapd/backend
        type: select
        value: MDB # Or HDB depending on Ubuntu/slapd version
      # Allow removal of database on purge? (Typically 'No')
      - name: slapd/remove_database
        question: slapd/remove_database
        type: boolean
        value: "false"
      # Move old database? (Usually 'Yes' if upgrading)
      - name: slapd/move_old_database
        question: slapd/move_old_database
        type: boolean
        value: "true"

  handlers:
    - name: restart slapd
      ansible.builtin.service:
        name: slapd
        state: restarted

  tasks:
    # --------------------------------------------------------------------------
    # 1. Pre-configure Debconf Selections
    # --------------------------------------------------------------------------
    - name: Set Debconf selections for slapd
      ansible.builtin.debconf:
        name: "{{ item.name }}"
        question: "{{ item.question }}"
        vtype: "{{ item.type }}"
        value: "{{ item.value }}"
      loop: "{{ slapd_debconf_selections }}"
      when: item.value is defined # Only set if value is defined

    # --------------------------------------------------------------------------
    # 2. Install LDAP Packages
    # --------------------------------------------------------------------------
    - name: Install OpenLDAP server and utils
      ansible.builtin.apt:
        name:
          - slapd
          - ldap-utils
        state: present
        update_cache: yes

    # --------------------------------------------------------------------------
    # 3. Reconfigure Slapd (Optional but Ensures Debconf Settings Apply)
    # --------------------------------------------------------------------------
    # Sometimes needed if initial install doesn't pick up all debconf settings
    # dpkg-reconfigure uses the debconf values set previously.
    - name: Reconfigure slapd using dpkg-reconfigure
      ansible.builtin.command: "dpkg-reconfigure -f noninteractive slapd"
      changed_when: false # Assume change already handled by install/debconf

    # --------------------------------------------------------------------------
    # 4. Configure TLS (Self-Signed Example)
    # --------------------------------------------------------------------------
    - name: Create directory for TLS certs
      ansible.builtin.file:
        path: "{{ ldap_tls_certs_path }}"
        state: directory
        owner: openldap
        group: openldap
        mode: '0700'

    - name: Generate OpenSSL private key (if it doesn't exist)
      community.crypto.openssl_privatekey:
        path: "{{ ldap_tls_key_file }}"
        owner: openldap
        group: openldap
        mode: '0600' # Key should be private
      notify: restart slapd

    - name: Generate OpenSSL CSR (if cert doesn't exist)
      community.crypto.openssl_csr:
        path: "/tmp/ldap.csr" # Temporary CSR file
        privatekey_path: "{{ ldap_tls_key_file }}"
        common_name: "{{ ansible_fqdn }}" # Use the server's FQDN
      when: not (ansible_check_mode or (ldap_tls_cert_file is file))

    - name: Generate Self-Signed OpenSSL certificate (if it doesn't exist)
      community.crypto.x509_certificate:
        path: "{{ ldap_tls_cert_file }}"
        csr_path: "/tmp/ldap.csr"
        privatekey_path: "{{ ldap_tls_key_file }}"
        provider: selfsigned
        owner: openldap
        group: openldap
        mode: '0644'
      when: not (ansible_check_mode or (ldap_tls_cert_file is file))
      notify: restart slapd

    - name: Template LDIF for TLS configuration
      ansible.builtin.template:
        src: templates/tls.ldif.j2
        dest: /tmp/tls.ldif
        mode: '0644'
      notify: restart slapd

    - name: Apply TLS LDIF configuration
      ansible.builtin.command: "ldapmodify -Y EXTERNAL -H ldapi:/// -f /tmp/tls.ldif"
      # Check if TLS is already configured - basic check, might need improvement
      # This command checks if olcTLSCertificateFile is already set in the config backend
      when: "'olcTLSCertificateFile' not in ldapsearch_config_tls_check_result.stdout"
      register: ldapmodify_tls_result
      changed_when: ldapmodify_tls_result.rc == 0
      notify: restart slapd

    - name: Check current TLS config (for idempotency)
      ansible.builtin.command: "ldapsearch -Y EXTERNAL -H ldapi:/// -b cn=config '(olcTLSCertificateFile={{ ldap_tls_cert_file }})' olcTLSCertificateFile"
      register: ldapsearch_config_tls_check_result
      changed_when: false
      failed_when: false # Don't fail if the entry doesn't exist yet

    # --------------------------------------------------------------------------
    # 5. Configure ACLs (Example - Needs Customization!)
    # --------------------------------------------------------------------------
    # WARNING: This is a *very* basic example. Review and customize ACLs carefully!
    - name: Template LDIF for basic ACLs
      ansible.builtin.template:
        src: templates/acls.ldif.j2
        dest: /tmp/acls.ldif
        mode: '0644'
      notify: restart slapd

    - name: Apply ACLs LDIF configuration
      ansible.builtin.command: "ldapmodify -Y EXTERNAL -H ldapi:/// -f /tmp/acls.ldif"
      register: ldapmodify_acl_result
      changed_when: ldapmodify_acl_result.rc == 0
      notify: restart slapd
      # Add a check here similar to TLS if needed for better idempotency

    # --------------------------------------------------------------------------
    # 6. Ensure Service is Running and Enabled
    # --------------------------------------------------------------------------
    - name: Ensure slapd service is running and enabled
      ansible.builtin.service:
        name: slapd
        state: started
        enabled: yes



  # tasks:
  #   - name: Update APT package cache
  #     ansible.builtin.apt:
  #       update_cache: yes
  #       cache_valid_time: 3600 # Only update if cache is older than 1 hour
  #     changed_when: false # Don't report change for cache update

  #   - name: Upgrade all APT packages
  #     ansible.builtin.apt:
  #       upgrade: dist # Upgrade everything, handling dependencies

  #   - name: Install common packages (optional)
  #     ansible.builtin.apt:
  #       name:
  #         - vim
  #         - git
  #         - curl
  #         - ufw # Uncomplicated Firewall
  #         - fail2ban
  #       state: present

  #   # --- Optional: Create a non-root admin user ---
  #   - name: Create an admin user
  #     ansible.builtin.user:
  #       name: "{{ admin_user }}"
  #       state: present
  #       shell: /bin/bash
  #       groups: sudo # Add user to sudo group
  #       append: yes
  #       create_home: yes

  #   - name: Set up authorized keys for the admin user
  #     ansible.posix.authorized_key:
  #       user: "{{ admin_user }}"
  #       state: present
  #       key: "{{ lookup('file', ssh_private_key_file + '.pub') }}" # Assumes pub key is next to private key

  #   # --- Optional: Basic UFW Firewall Setup ---
  #   - name: Allow SSH through UFW
  #     community.general.ufw:
  #       rule: allow
  #       port: '22'
  #       proto: tcp

  #   - name: Allow HTTP through UFW (if needed)
  #     community.general.ufw:
  #       rule: allow
  #       port: '80'
  #       proto: tcp

  #   - name: Allow HTTPS through UFW (if needed)
  #     community.general.ufw:
  #       rule: allow
  #       port: '443'
  #       proto: tcp

  #   - name: Deny all other incoming traffic by default
  #     community.general.ufw:
  #       state: enabled
  #       policy: deny
  #       direction: incoming

  #   - name: Server Configuration Complete Message
  #     ansible.builtin.debug:
  #       msg: "Basic configuration applied to {{ inventory_hostname }}"
